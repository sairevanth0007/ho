<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: config/passport-setup.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: config/passport-setup.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file config/passport-setup.js
 * @description Passport.js authentication strategies setup.
 * @author GIDE
 */

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as MicrosoftStrategy } from 'passport-microsoft';
import { Strategy as GitHubStrategy } from 'passport-github2';
import mongoose from 'mongoose';

import { User } from '../models/user.model.js';
import { Referral } from '../models/referral.model.js';
import { bridge } from '../bridge.js';
import { PlanTypes, OAuthProviders, AppMessages } from '../constants/index.js';
import { ApiError } from '../utils/ApiError.js';

// Helper function to add duration to a date
function addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

function addMonths(date, months) {
    const result = new Date(date);
    result.setMonth(result.getMonth() + months);
    return result;
}

/**
 * @function passport.serializeUser
 * @description Determines which data of the user object should be stored in the session.
 * The result of the serializeUser method is attached to the session as req.session.passport.user = {value}.
 * @param {User} user - The user object provided by the strategy's verify callback.
 * @param {Function} done - Callback to tell Passport it's done.
 */
passport.serializeUser((user, done) => {
    done(null, user.id); // Store user.id in session
});

/**
 * @function passport.deserializeUser
 * @description Retrieves user data from the session.
 * The object stored in the session (user.id) is used to retrieve the full user object.
 * This full user object is then attached to the request as req.user.
 * @param {string} id - The user ID stored in the session.
 * @param {Function} done - Callback to tell Passport it's done.
 */
passport.deserializeUser(async (id, done) => {
    try {
        const user = await User.findById(id);
        done(null, user); // Attach user object to req.user
    } catch (error) {
        done(error, null);
    }
});

const OAUTH_VERIFY_CALLBACK = async (req, accessToken, refreshToken, profile, done) => {
    const provider = profile.provider; // 'google', 'microsoft', 'github'
    const providerId = profile.id;
    let email = profile.emails &amp;&amp; profile.emails[0] ? profile.emails[0].value : null;
    let name = profile.displayName || profile.username || `${profile.name?.givenName || ''} ${profile.name?.familyName || ''}`.trim();
    let avatar = profile.photos &amp;&amp; profile.photos[0] ? profile.photos[0].value : null;

    // Fallback for GitHub if email is null (user might have private email)
    if (provider === OAuthProviders.GITHUB &amp;&amp; !email &amp;&amp; accessToken) {
        try {
            const res = await fetch('https://api.github.com/user/emails', {
                headers: { Authorization: `token ${accessToken}` },
            });
            const emails = await res.json();
            if (Array.isArray(emails) &amp;&amp; emails.length > 0) {
                const primaryEmail = emails.find(e => e.primary &amp;&amp; e.verified);
                email = primaryEmail ? primaryEmail.email : emails[0].email;
            }
        } catch (err) {
            console.error('Error fetching GitHub email:', err);
            return done(new ApiError(500, 'Failed to fetch email from GitHub.'));
        }
    }
    
    if (!email) {
        // This could happen if email is not provided or not fetchable
        return done(null, false, { message: `Email not provided by ${provider}. Please ensure your ${provider} account has a public email.` });
    }
    if (!name) name = email.split('@')[0]; // Fallback name

    const sessionReferralCode = req.session.referralCode;
    if (req.session.referralCode) delete req.session.referralCode; // Clear after use


    try {
        let user = await User.findOne({ provider: provider, providerId: providerId });

        if (user) {
            // User exists, update last login and potentially avatar
            user.lastLoginAt = new Date();
            if (avatar &amp;&amp; user.avatar !== avatar) user.avatar = avatar;
            if (name &amp;&amp; user.name !== name) user.name = name; // Update name if changed
            await user.save();
            return done(null, user);
        } else {
            // New user registration
            // Check if email is already registered with another provider
            const existingUserWithEmail = await User.findOne({ email: email });
            if (existingUserWithEmail) {
                return done(null, false, { message: `Email ${email} is already registered using ${existingUserWithEmail.provider}. Please login with ${existingUserWithEmail.provider} or use a different email.` });
            }

            // Create new user
            const newUser = new User({
                email,
                name,
                avatar,
                provider,
                providerId,
                lastLoginAt: new Date(),
            });

            // 1. Assign Free Trial
            const freeTrialDurationDays = parseInt(process.env.DEFAULT_FREE_TRIAL_DURATION_DAYS, 10) || 30;
            newUser.subscriptionStatus = PlanTypes.FREE_TRIAL;
            newUser.currentPlanType = PlanTypes.FREE_TRIAL;
            newUser.subscriptionExpiresAt = addDays(new Date(), freeTrialDurationDays);
            newUser.hasUsedFreeTrial = true;
            newUser.isFreeTrialEligible = false;

            // 2. Handle incoming referral code (if any)
            if (sessionReferralCode) {
                const referralDoc = await Referral.findOne({ referralCode: sessionReferralCode }).populate('userId');
                if (referralDoc &amp;&amp; referralDoc.userId) {
                    const referringUser = await User.findById(referralDoc.userId); // Or use referralDoc.userId which is already populated if schema is setup that way.
                                                                                // For safety, fetch fresh user doc.

                    if (referringUser &amp;&amp; referringUser._id.toString() !== newUser._id.toString()) { // Cannot refer self
                        newUser.referredBy = referringUser._id;

                        // Add 1 month subscription to the referring user
                        let newExpiry;
                        if (!referringUser.subscriptionExpiresAt || referringUser.subscriptionExpiresAt &lt; new Date()) {
                            newExpiry = addMonths(new Date(), 1);
                        } else {
                            newExpiry = addMonths(new Date(referringUser.subscriptionExpiresAt), 1);
                        }
                        referringUser.subscriptionExpiresAt = newExpiry;
                        // If user had no active plan, this could be their first "active" period.
                        // Status update for referrer might be complex and depend on current state,
                        // for simplicity now we just extend/grant expiry.
                        // e.g. if they were `PlanTypes.FREE_TRIAL` and it expired, now it's effectively extended.
                        // if they had a paid plan, it's extended.

                        await referringUser.save();

                        referralDoc.numberOfReferrals += 1;
                        await referralDoc.save();
                        console.log(`Referral bonus applied to user ${referringUser.email} from new user ${newUser.email}`);
                    }
                } else {
                     console.warn(`Invalid or non-existent referral code used: ${sessionReferralCode}`);
                }
            }
            await newUser.save(); // Save new user

            // 3. Generate user's own referral code
            try {
                let uniqueCodeGenerated = false;
                let newReferralCode;
                let attempts = 0;
                const MAX_ATTEMPTS = 5;

                while(!uniqueCodeGenerated &amp;&amp; attempts &lt; MAX_ATTEMPTS) {
                    newReferralCode = Referral.generateReferralCode(newUser.name);
                    const existingCode = await Referral.findOne({ referralCode: newReferralCode});
                    if (!existingCode) {
                        uniqueCodeGenerated = true;
                    }
                    attempts++;
                }

                if (!uniqueCodeGenerated) {
                    // Fallback to a more random code if name-based is clashing too much
                    newReferralCode = `REF${crypto.randomBytes(4).toString('hex').toUpperCase()}`;
                }

                const userReferral = new Referral({
                    userId: newUser._id,
                    referralCode: newReferralCode,
                });
                await userReferral.save();
                newUser.referralDetails = userReferral._id;
                await newUser.save(); // Save user again with referralDetails link
            } catch (referralError) {
                console.error(`Failed to create referral code for ${newUser.email}:`, referralError);
                // Continue user creation even if referral code generation fails, log error
            }
            return done(null, newUser);
        }
    } catch (error) {
        console.error(`OAuth Error for ${provider} user ${email}:`, error);
        if (error.code === 11000) { // Duplicate key error from MongoDB
             return done(null, false, { message: AppMessages.USER_ALREADY_EXISTS });
        }
        return done(error);
    }
};


// Google Strategy
passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: `${bridge.BASE_URL}${process.env.GOOGLE_CALLBACK_URL}`, // e.g., http://localhost:8000/api/v1/auth/google/callback
    passReqToCallback: true, // Allows us to access req in the verify callback
}, OAUTH_VERIFY_CALLBACK));

// Microsoft Strategy
passport.use(new MicrosoftStrategy({
    clientID: process.env.MICROSOFT_CLIENT_ID,
    clientSecret: process.env.MICROSOFT_CLIENT_SECRET,
    callbackURL: `${bridge.BASE_URL}${process.env.MICROSOFT_CALLBACK_URL}`,
    scope: ['openid', 'profile', 'email', 'User.Read'], // Common scopes
    tenant: process.env.MICROSOFT_TENANT_ID || 'common',
    passReqToCallback: true,
}, OAUTH_VERIFY_CALLBACK));

// GitHub Strategy
passport.use(new GitHubStrategy({
    clientID: process.env.GITHUB_CLIENT_ID,
    clientSecret: process.env.GITHUB_CLIENT_SECRET,
    callbackURL: `${bridge.BASE_URL}${process.env.GITHUB_CALLBACK_URL}`,
    scope: ['user:email', 'read:user'], // Scopes to get email and user profile
    passReqToCallback: true,
}, OAUTH_VERIFY_CALLBACK));

export default passport;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="bridge.html">bridge</a></li></ul><h3>Classes</h3><ul><li><a href="ApiError.html">ApiError</a></li><li><a href="ApiResponse.html">ApiResponse</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AppMessages">AppMessages</a></li><li><a href="global.html#BASE_URL">BASE_URL</a></li><li><a href="global.html#DB_NAME">DB_NAME</a></li><li><a href="global.html#FRONTEND_URL">FRONTEND_URL</a></li><li><a href="global.html#HttpStatusCode">HttpStatusCode</a></li><li><a href="global.html#OAuthProviders">OAuthProviders</a></li><li><a href="global.html#PlanTypes">PlanTypes</a></li><li><a href="global.html#STRIPE_PLAN_PRICE_IDS">STRIPE_PLAN_PRICE_IDS</a></li><li><a href="global.html#STRIPE_WEBHOOK_SECRET">STRIPE_WEBHOOK_SECRET</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#connectDB">connectDB</a></li><li><a href="global.html#createCheckoutSession">createCheckoutSession</a></li><li><a href="global.html#createRateLimiter">createRateLimiter</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#getCurrentUser">getCurrentUser</a></li><li><a href="global.html#handleOAuthFailure">handleOAuthFailure</a></li><li><a href="global.html#handleOAuthSuccess">handleOAuthSuccess</a></li><li><a href="global.html#handleStripeWebhook">handleStripeWebhook</a></li><li><a href="global.html#isAuthenticated">isAuthenticated</a></li><li><a href="global.html#logoutUser">logoutUser</a></li><li><a href="global.html#manageSubscriptionPortal">manageSubscriptionPortal</a></li><li><a href="global.html#rateLimiter">rateLimiter</a></li><li><a href="global.html#stripe">stripe</a></li><li><a href="global.html#upgradeToYearly">upgradeToYearly</a></li><li><a href="global.html#validate">validate</a></li><li><a href="global.html#validatePlanIdSchema">validatePlanIdSchema</a></li><li><a href="global.html#validateReferralCodeSchema">validateReferralCodeSchema</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat May 31 2025 22:19:47 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
